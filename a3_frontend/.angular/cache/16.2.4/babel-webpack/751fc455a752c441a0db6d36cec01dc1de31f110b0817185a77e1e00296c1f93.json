{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/annag/OneDrive/Pulpit/a3_backend/a3_frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst fs = require('fs');\nconst sysPath = require('path');\nconst {\n  promisify\n} = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\nconst statMethods = {\n  lstat,\n  stat\n};\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    });\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler,\n    // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (error) {\n        const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n        cont.watcherUnusable = true; // documented since Node 10.4.1\n        // Workaround for https://github.com/joyent/node/issues/4337\n        if (isWindows && error.code === 'EPERM') {\n          try {\n            const fd = yield open(path, 'r');\n            yield close(fd);\n            broadcastErr(error);\n          } catch (err) {}\n        } else {\n          broadcastErr(error);\n        }\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath.dirname(path);\n    const basename = sysPath.basename(path);\n    const parent = this.fsw._getWatchedDir(directory);\n    parent.add(basename);\n    const absolutePath = sysPath.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN;\n    let closer;\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n    return closer;\n  }\n\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n  _handleFile(file, stats, initialAdd) {\n    var _this = this;\n    if (this.fsw.closed) {\n      return;\n    }\n    const dirname = sysPath.dirname(file);\n    const basename = sysPath.basename(file);\n    const parent = this.fsw._getWatchedDir(dirname);\n    // stats is always present\n    let prevStats = stats;\n\n    // if the file is already being watched, do nothing\n    if (parent.has(basename)) return;\n    const listener = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (path, newStats) {\n        if (!_this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n        if (!newStats || newStats.mtimeMs === 0) {\n          try {\n            const newStats = yield stat(file);\n            if (_this.fsw.closed) return;\n            // Check that change event was not fired because of changed only accessTime.\n            const at = newStats.atimeMs;\n            const mt = newStats.mtimeMs;\n            if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n              _this.fsw._emit(EV_CHANGE, file, newStats);\n            }\n            if (isLinux && prevStats.ino !== newStats.ino) {\n              _this.fsw._closeFile(path);\n              prevStats = newStats;\n              _this.fsw._addPathCloser(path, _this._watchWithNodeFs(file, listener));\n            } else {\n              prevStats = newStats;\n            }\n          } catch (error) {\n            // Fix issues where mtime is null but file is still present\n            _this.fsw._remove(dirname, basename);\n          }\n          // add is about to be emitted if file not already tracked in parent\n        } else if (parent.has(basename)) {\n          // Check that change event was not fired because of changed only accessTime.\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            _this.fsw._emit(EV_CHANGE, file, newStats);\n          }\n          prevStats = newStats;\n        }\n      });\n      return function listener(_x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    // kick off the watcher\n    const closer = this._watchWithNodeFs(file, listener);\n\n    // emit an add event if we're supposed to\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n      this.fsw._emit(EV_ADD, file, stats);\n    }\n    return closer;\n  }\n\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n  _handleSymlink(entry, directory, path, item) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.fsw.closed) {\n        return;\n      }\n      const full = entry.fullPath;\n      const dir = _this2.fsw._getWatchedDir(directory);\n      if (!_this2.fsw.options.followSymlinks) {\n        // watch symlink directly (don't follow) and detect changes\n        _this2.fsw._incrReadyCount();\n        let linkPath;\n        try {\n          linkPath = yield fsrealpath(path);\n        } catch (e) {\n          _this2.fsw._emitReady();\n          return true;\n        }\n        if (_this2.fsw.closed) return;\n        if (dir.has(item)) {\n          if (_this2.fsw._symlinkPaths.get(full) !== linkPath) {\n            _this2.fsw._symlinkPaths.set(full, linkPath);\n            _this2.fsw._emit(EV_CHANGE, path, entry.stats);\n          }\n        } else {\n          dir.add(item);\n          _this2.fsw._symlinkPaths.set(full, linkPath);\n          _this2.fsw._emit(EV_ADD, path, entry.stats);\n        }\n        _this2.fsw._emitReady();\n        return true;\n      }\n\n      // don't follow the same symlink more than once\n      if (_this2.fsw._symlinkPaths.has(full)) {\n        return true;\n      }\n      _this2.fsw._symlinkPaths.set(full, true);\n    })();\n  }\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    var _this3 = this;\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, EMPTY_STR);\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n    const previous = this.fsw._getWatchedDir(wh.path);\n    const current = new Set();\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA, /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (entry) {\n        if (_this3.fsw.closed) {\n          stream = undefined;\n          return;\n        }\n        const item = entry.path;\n        let path = sysPath.join(directory, item);\n        current.add(item);\n        if (entry.stats.isSymbolicLink() && (yield _this3._handleSymlink(entry, directory, path, item))) {\n          return;\n        }\n        if (_this3.fsw.closed) {\n          stream = undefined;\n          return;\n        }\n        // Files that present in current directory snapshot\n        // but absent in previous are added to watch list and\n        // emit `add` event.\n        if (item === target || !target && !previous.has(item)) {\n          _this3.fsw._incrReadyCount();\n\n          // ensure relativeness of path is preserved in case of watcher reuse\n          path = sysPath.join(dir, sysPath.relative(dir, path));\n          _this3._addToNodeFs(path, initialAdd, wh, depth + 1);\n        }\n      });\n      return function (_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }()).on(EV_ERROR, this._boundHandleError);\n    return new Promise(resolve => stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && (\n        // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n  _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const parentDir = _this4.fsw._getWatchedDir(sysPath.dirname(dir));\n      const tracked = parentDir.has(sysPath.basename(dir));\n      if (!(initialAdd && _this4.fsw.options.ignoreInitial) && !target && !tracked) {\n        if (!wh.hasGlob || wh.globFilter(dir)) _this4.fsw._emit(EV_ADD_DIR, dir, stats);\n      }\n\n      // ensure dir is tracked (harmless if redundant)\n      parentDir.add(sysPath.basename(dir));\n      _this4.fsw._getWatchedDir(dir);\n      let throttler;\n      let closer;\n      const oDepth = _this4.fsw.options.depth;\n      if ((oDepth == null || depth <= oDepth) && !_this4.fsw._symlinkPaths.has(realpath)) {\n        if (!target) {\n          yield _this4._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n          if (_this4.fsw.closed) return;\n        }\n        closer = _this4._watchWithNodeFs(dir, (dirPath, stats) => {\n          // if current directory is removed, do nothing\n          if (stats && stats.mtimeMs === 0) return;\n          _this4._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n        });\n      }\n      return closer;\n    })();\n  }\n\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n  _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const ready = _this5.fsw._emitReady;\n      if (_this5.fsw._isIgnored(path) || _this5.fsw.closed) {\n        ready();\n        return false;\n      }\n      const wh = _this5.fsw._getWatchHelpers(path, depth);\n      if (!wh.hasGlob && priorWh) {\n        wh.hasGlob = priorWh.hasGlob;\n        wh.globFilter = priorWh.globFilter;\n        wh.filterPath = entry => priorWh.filterPath(entry);\n        wh.filterDir = entry => priorWh.filterDir(entry);\n      }\n\n      // evaluate what is at the path we're being asked to watch\n      try {\n        const stats = yield statMethods[wh.statMethod](wh.watchPath);\n        if (_this5.fsw.closed) return;\n        if (_this5.fsw._isIgnored(wh.watchPath, stats)) {\n          ready();\n          return false;\n        }\n        const follow = _this5.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n        let closer;\n        if (stats.isDirectory()) {\n          const absPath = sysPath.resolve(path);\n          const targetPath = follow ? yield fsrealpath(path) : path;\n          if (_this5.fsw.closed) return;\n          closer = yield _this5._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n          if (_this5.fsw.closed) return;\n          // preserve this symlink's target path\n          if (absPath !== targetPath && targetPath !== undefined) {\n            _this5.fsw._symlinkPaths.set(absPath, targetPath);\n          }\n        } else if (stats.isSymbolicLink()) {\n          const targetPath = follow ? yield fsrealpath(path) : path;\n          if (_this5.fsw.closed) return;\n          const parent = sysPath.dirname(wh.watchPath);\n          _this5.fsw._getWatchedDir(parent).add(wh.watchPath);\n          _this5.fsw._emit(EV_ADD, wh.watchPath, stats);\n          closer = yield _this5._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n          if (_this5.fsw.closed) return;\n\n          // preserve this symlink's target path\n          if (targetPath !== undefined) {\n            _this5.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n          }\n        } else {\n          closer = _this5._handleFile(wh.watchPath, stats, initialAdd);\n        }\n        ready();\n        _this5.fsw._addPathCloser(path, closer);\n        return false;\n      } catch (error) {\n        if (_this5.fsw._handleError(error)) {\n          ready();\n          return path;\n        }\n      }\n    })();\n  }\n}\nmodule.exports = NodeFsHandler;","map":{"version":3,"names":["_asyncToGenerator","require","default","fs","sysPath","promisify","isBinaryPath","isWindows","isLinux","EMPTY_FN","EMPTY_STR","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","EV_CHANGE","EV_ADD","EV_ADD_DIR","EV_ERROR","STR_DATA","STR_END","BRACE_START","STAR","THROTTLE_MODE_WATCH","open","stat","lstat","close","fsrealpath","realpath","statMethods","foreach","val","fn","Set","forEach","addAndConvert","main","prop","item","container","add","clearItem","cont","key","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","path","options","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","resolve","join","watch","error","fullPath","type","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","on","_ref","broadcastErr","watcherUnusable","code","fd","err","_x","apply","arguments","listeners","errHandlers","rawEmitters","undefined","Object","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","prev","currmtime","mtimeMs","NodeFsHandler","constructor","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","opts","directory","dirname","basename","parent","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","stats","initialAdd","_this","closed","prevStats","has","_ref2","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","_x2","_x3","ignoreInitial","_isntIgnored","_handleSymlink","entry","_this2","full","dir","followSymlinks","_incrReadyCount","linkPath","e","_emitReady","_symlinkPaths","_handleRead","wh","target","depth","throttler","_this3","hasGlob","previous","current","stream","_readdirp","fileFilter","filterPath","directoryFilter","filterDir","_ref3","isSymbolicLink","relative","_addToNodeFs","_x4","Promise","once","wasThrottled","getChildren","filter","_handleDir","_this4","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","_this5","ready","_isIgnored","_getWatchHelpers","statMethod","watchPath","follow","includes","isDirectory","absPath","targetPath","module","exports"],"sources":["C:/Users/annag/OneDrive/Pulpit/a3_backend/a3_frontend/node_modules/chokidar/lib/nodefs-handler.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}